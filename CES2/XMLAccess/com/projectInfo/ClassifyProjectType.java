/**
 * ClassifyProjectType.java
 *
 * This file was generated by XMLSpy 2006sp2 Enterprise Edition.
 *
 * YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
 * OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
 *
 * Refer to the XMLSpy Documentation for further details.
 * http://www.altova.com/xmlspy
 */


package com.projectInfo;

import com.altova.types.SchemaDouble;
import com.altova.types.SchemaString;

public class ClassifyProjectType extends com.altova.xml.Node {

	public ClassifyProjectType(ClassifyProjectType node) {
		super(node);
	}

	public ClassifyProjectType(org.w3c.dom.Node node) {
		super(node);
	}

	public ClassifyProjectType(org.w3c.dom.Document doc) {
		super(doc);
	}

	public ClassifyProjectType(com.altova.xml.Document doc, String namespaceURI, String prefix, String name) {
		super(doc, namespaceURI, prefix, name);
	}
	
	public void adjustPrefix() {
		for (	org.w3c.dom.Node tmpNode = getDomFirstChild( Element, null, "projectName" );
				tmpNode != null;
				tmpNode = getDomNextChild( Element, null, "projectName", tmpNode )
			) {
			internalAdjustPrefix(tmpNode, true);
		}
		for (	org.w3c.dom.Node tmpNode = getDomFirstChild( Element, null, "workspace" );
				tmpNode != null;
				tmpNode = getDomNextChild( Element, null, "workspace", tmpNode )
			) {
			internalAdjustPrefix(tmpNode, true);
		}
		for (	org.w3c.dom.Node tmpNode = getDomFirstChild( Element, null, "tempDirectory" );
				tmpNode != null;
				tmpNode = getDomNextChild( Element, null, "tempDirectory", tmpNode )
			) {
			internalAdjustPrefix(tmpNode, true);
		}
		for (	org.w3c.dom.Node tmpNode = getDomFirstChild( Element, null, "projectDescription" );
				tmpNode != null;
				tmpNode = getDomNextChild( Element, null, "projectDescription", tmpNode )
			) {
			internalAdjustPrefix(tmpNode, true);
		}
		for (	org.w3c.dom.Node tmpNode = getDomFirstChild( Element, null, "classifyRangePath" );
				tmpNode != null;
				tmpNode = getDomNextChild( Element, null, "classifyRangePath", tmpNode )
			) {
			internalAdjustPrefix(tmpNode, true);
		}
		for (	org.w3c.dom.Node tmpNode = getDomFirstChild( Element, null, "obstructPath" );
				tmpNode != null;
				tmpNode = getDomNextChild( Element, null, "obstructPath", tmpNode )
			) {
			internalAdjustPrefix(tmpNode, true);
		}
		for (	org.w3c.dom.Node tmpNode = getDomFirstChild( Element, null, "cellSize" );
				tmpNode != null;
				tmpNode = getDomNextChild( Element, null, "cellSize", tmpNode )
			) {
			internalAdjustPrefix(tmpNode, true);
		}
		for (	org.w3c.dom.Node tmpNode = getDomFirstChild( Element, null, "bgMapPath" );
				tmpNode != null;
				tmpNode = getDomNextChild( Element, null, "bgMapPath", tmpNode )
			) {
			internalAdjustPrefix(tmpNode, true);
		}
		for (	org.w3c.dom.Node tmpNode = getDomFirstChild( Element, null, "FFTable" );
				tmpNode != null;
				tmpNode = getDomNextChild( Element, null, "FFTable", tmpNode )
			) {
			internalAdjustPrefix(tmpNode, true);
		}
	}

	public static int getprojectNameMinCount() {
		return 1;
	}

	public static int getprojectNameMaxCount() {
		return 1;
	}

	public int getprojectNameCount() {
		return getDomChildCount(Element, null, "projectName");
	}

	public boolean hasprojectName() {
		return hasDomChild(Element, null, "projectName");
	}

	public SchemaString newprojectName() {
		return new SchemaString();
	}

	public SchemaString getprojectNameAt(int index) throws Exception {
		return new SchemaString(getDomNodeValue(dereference(getDomChildAt(Element, null, "projectName", index))));
	}

	public org.w3c.dom.Node getStartingprojectNameCursor() throws Exception {
		return getDomFirstChild(Element, null, "projectName" );
	}

	public org.w3c.dom.Node getAdvancedprojectNameCursor( org.w3c.dom.Node curNode ) throws Exception {
		return getDomNextChild( Element, null, "projectName", curNode );
	}

	public SchemaString getprojectNameValueAtCursor( org.w3c.dom.Node curNode ) throws Exception {
		if( curNode == null )
			throw new com.altova.xml.XmlException("Out of range");
		else
			return new SchemaString(getDomNodeValue( dereference(curNode) ) );
	}

	public SchemaString getprojectName() throws Exception 
 {
		return getprojectNameAt(0);
	}

	public void removeprojectNameAt(int index) {
		removeDomChildAt(Element, null, "projectName", index);
	}

	public void removeprojectName() {
		while (hasprojectName())
			removeprojectNameAt(0);
	}

	public void addprojectName(SchemaString value) {
		if( value.isNull() == false )
		{
			appendDomChild(Element, null, "projectName", value.toString());
		}
	}

	public void addprojectName(String value) throws Exception {
		addprojectName(new SchemaString(value));
	}

	public void insertprojectNameAt(SchemaString value, int index) {
		insertDomChildAt(Element, null, "projectName", index, value.toString());
	}

	public void insertprojectNameAt(String value, int index) throws Exception {
		insertprojectNameAt(new SchemaString(value), index);
	}

	public void replaceprojectNameAt(SchemaString value, int index) {
		replaceDomChildAt(Element, null, "projectName", index, value.toString());
	}

	public void replaceprojectNameAt(String value, int index) throws Exception {
		replaceprojectNameAt(new SchemaString(value), index);
	}

	public static int getworkspaceMinCount() {
		return 1;
	}

	public static int getworkspaceMaxCount() {
		return 1;
	}

	public int getworkspaceCount() {
		return getDomChildCount(Element, null, "workspace");
	}

	public boolean hasworkspace() {
		return hasDomChild(Element, null, "workspace");
	}

	public SchemaString newworkspace() {
		return new SchemaString();
	}

	public SchemaString getworkspaceAt(int index) throws Exception {
		return new SchemaString(getDomNodeValue(dereference(getDomChildAt(Element, null, "workspace", index))));
	}

	public org.w3c.dom.Node getStartingworkspaceCursor() throws Exception {
		return getDomFirstChild(Element, null, "workspace" );
	}

	public org.w3c.dom.Node getAdvancedworkspaceCursor( org.w3c.dom.Node curNode ) throws Exception {
		return getDomNextChild( Element, null, "workspace", curNode );
	}

	public SchemaString getworkspaceValueAtCursor( org.w3c.dom.Node curNode ) throws Exception {
		if( curNode == null )
			throw new com.altova.xml.XmlException("Out of range");
		else
			return new SchemaString(getDomNodeValue( dereference(curNode) ) );
	}

	public SchemaString getworkspace() throws Exception 
 {
		return getworkspaceAt(0);
	}

	public void removeworkspaceAt(int index) {
		removeDomChildAt(Element, null, "workspace", index);
	}

	public void removeworkspace() {
		while (hasworkspace())
			removeworkspaceAt(0);
	}

	public void addworkspace(SchemaString value) {
		if( value.isNull() == false )
		{
			appendDomChild(Element, null, "workspace", value.toString());
		}
	}

	public void addworkspace(String value) throws Exception {
		addworkspace(new SchemaString(value));
	}

	public void insertworkspaceAt(SchemaString value, int index) {
		insertDomChildAt(Element, null, "workspace", index, value.toString());
	}

	public void insertworkspaceAt(String value, int index) throws Exception {
		insertworkspaceAt(new SchemaString(value), index);
	}

	public void replaceworkspaceAt(SchemaString value, int index) {
		replaceDomChildAt(Element, null, "workspace", index, value.toString());
	}

	public void replaceworkspaceAt(String value, int index) throws Exception {
		replaceworkspaceAt(new SchemaString(value), index);
	}

	public static int gettempDirectoryMinCount() {
		return 1;
	}

	public static int gettempDirectoryMaxCount() {
		return 1;
	}

	public int gettempDirectoryCount() {
		return getDomChildCount(Element, null, "tempDirectory");
	}

	public boolean hastempDirectory() {
		return hasDomChild(Element, null, "tempDirectory");
	}

	public SchemaString newtempDirectory() {
		return new SchemaString();
	}

	public SchemaString gettempDirectoryAt(int index) throws Exception {
		return new SchemaString(getDomNodeValue(dereference(getDomChildAt(Element, null, "tempDirectory", index))));
	}

	public org.w3c.dom.Node getStartingtempDirectoryCursor() throws Exception {
		return getDomFirstChild(Element, null, "tempDirectory" );
	}

	public org.w3c.dom.Node getAdvancedtempDirectoryCursor( org.w3c.dom.Node curNode ) throws Exception {
		return getDomNextChild( Element, null, "tempDirectory", curNode );
	}

	public SchemaString gettempDirectoryValueAtCursor( org.w3c.dom.Node curNode ) throws Exception {
		if( curNode == null )
			throw new com.altova.xml.XmlException("Out of range");
		else
			return new SchemaString(getDomNodeValue( dereference(curNode) ) );
	}

	public SchemaString gettempDirectory() throws Exception 
 {
		return gettempDirectoryAt(0);
	}

	public void removetempDirectoryAt(int index) {
		removeDomChildAt(Element, null, "tempDirectory", index);
	}

	public void removetempDirectory() {
		while (hastempDirectory())
			removetempDirectoryAt(0);
	}

	public void addtempDirectory(SchemaString value) {
		if( value.isNull() == false )
		{
			appendDomChild(Element, null, "tempDirectory", value.toString());
		}
	}

	public void addtempDirectory(String value) throws Exception {
		addtempDirectory(new SchemaString(value));
	}

	public void inserttempDirectoryAt(SchemaString value, int index) {
		insertDomChildAt(Element, null, "tempDirectory", index, value.toString());
	}

	public void inserttempDirectoryAt(String value, int index) throws Exception {
		inserttempDirectoryAt(new SchemaString(value), index);
	}

	public void replacetempDirectoryAt(SchemaString value, int index) {
		replaceDomChildAt(Element, null, "tempDirectory", index, value.toString());
	}

	public void replacetempDirectoryAt(String value, int index) throws Exception {
		replacetempDirectoryAt(new SchemaString(value), index);
	}

	public static int getprojectDescriptionMinCount() {
		return 0;
	}

	public static int getprojectDescriptionMaxCount() {
		return 1;
	}

	public int getprojectDescriptionCount() {
		return getDomChildCount(Element, null, "projectDescription");
	}

	public boolean hasprojectDescription() {
		return hasDomChild(Element, null, "projectDescription");
	}

	public SchemaString newprojectDescription() {
		return new SchemaString();
	}

	public SchemaString getprojectDescriptionAt(int index) throws Exception {
		return new SchemaString(getDomNodeValue(dereference(getDomChildAt(Element, null, "projectDescription", index))));
	}

	public org.w3c.dom.Node getStartingprojectDescriptionCursor() throws Exception {
		return getDomFirstChild(Element, null, "projectDescription" );
	}

	public org.w3c.dom.Node getAdvancedprojectDescriptionCursor( org.w3c.dom.Node curNode ) throws Exception {
		return getDomNextChild( Element, null, "projectDescription", curNode );
	}

	public SchemaString getprojectDescriptionValueAtCursor( org.w3c.dom.Node curNode ) throws Exception {
		if( curNode == null )
			throw new com.altova.xml.XmlException("Out of range");
		else
			return new SchemaString(getDomNodeValue( dereference(curNode) ) );
	}

	public SchemaString getprojectDescription() throws Exception 
 {
		return getprojectDescriptionAt(0);
	}

	public void removeprojectDescriptionAt(int index) {
		removeDomChildAt(Element, null, "projectDescription", index);
	}

	public void removeprojectDescription() {
		while (hasprojectDescription())
			removeprojectDescriptionAt(0);
	}

	public void addprojectDescription(SchemaString value) {
		if( value.isNull() == false )
		{
			appendDomChild(Element, null, "projectDescription", value.toString());
		}
	}

	public void addprojectDescription(String value) throws Exception {
		addprojectDescription(new SchemaString(value));
	}

	public void insertprojectDescriptionAt(SchemaString value, int index) {
		insertDomChildAt(Element, null, "projectDescription", index, value.toString());
	}

	public void insertprojectDescriptionAt(String value, int index) throws Exception {
		insertprojectDescriptionAt(new SchemaString(value), index);
	}

	public void replaceprojectDescriptionAt(SchemaString value, int index) {
		replaceDomChildAt(Element, null, "projectDescription", index, value.toString());
	}

	public void replaceprojectDescriptionAt(String value, int index) throws Exception {
		replaceprojectDescriptionAt(new SchemaString(value), index);
	}

	public static int getclassifyRangePathMinCount() {
		return 0;
	}

	public static int getclassifyRangePathMaxCount() {
		return 1;
	}

	public int getclassifyRangePathCount() {
		return getDomChildCount(Element, null, "classifyRangePath");
	}

	public boolean hasclassifyRangePath() {
		return hasDomChild(Element, null, "classifyRangePath");
	}

	public SchemaString newclassifyRangePath() {
		return new SchemaString();
	}

	public SchemaString getclassifyRangePathAt(int index) throws Exception {
		return new SchemaString(getDomNodeValue(dereference(getDomChildAt(Element, null, "classifyRangePath", index))));
	}

	public org.w3c.dom.Node getStartingclassifyRangePathCursor() throws Exception {
		return getDomFirstChild(Element, null, "classifyRangePath" );
	}

	public org.w3c.dom.Node getAdvancedclassifyRangePathCursor( org.w3c.dom.Node curNode ) throws Exception {
		return getDomNextChild( Element, null, "classifyRangePath", curNode );
	}

	public SchemaString getclassifyRangePathValueAtCursor( org.w3c.dom.Node curNode ) throws Exception {
		if( curNode == null )
			throw new com.altova.xml.XmlException("Out of range");
		else
			return new SchemaString(getDomNodeValue( dereference(curNode) ) );
	}

	public SchemaString getclassifyRangePath() throws Exception 
 {
		return getclassifyRangePathAt(0);
	}

	public void removeclassifyRangePathAt(int index) {
		removeDomChildAt(Element, null, "classifyRangePath", index);
	}

	public void removeclassifyRangePath() {
		while (hasclassifyRangePath())
			removeclassifyRangePathAt(0);
	}

	public void addclassifyRangePath(SchemaString value) {
		if( value.isNull() == false )
		{
			appendDomChild(Element, null, "classifyRangePath", value.toString());
		}
	}

	public void addclassifyRangePath(String value) throws Exception {
		addclassifyRangePath(new SchemaString(value));
	}

	public void insertclassifyRangePathAt(SchemaString value, int index) {
		insertDomChildAt(Element, null, "classifyRangePath", index, value.toString());
	}

	public void insertclassifyRangePathAt(String value, int index) throws Exception {
		insertclassifyRangePathAt(new SchemaString(value), index);
	}

	public void replaceclassifyRangePathAt(SchemaString value, int index) {
		replaceDomChildAt(Element, null, "classifyRangePath", index, value.toString());
	}

	public void replaceclassifyRangePathAt(String value, int index) throws Exception {
		replaceclassifyRangePathAt(new SchemaString(value), index);
	}

	public static int getobstructPathMinCount() {
		return 0;
	}

	public static int getobstructPathMaxCount() {
		return 1;
	}

	public int getobstructPathCount() {
		return getDomChildCount(Element, null, "obstructPath");
	}

	public boolean hasobstructPath() {
		return hasDomChild(Element, null, "obstructPath");
	}

	public SchemaString newobstructPath() {
		return new SchemaString();
	}

	public SchemaString getobstructPathAt(int index) throws Exception {
		return new SchemaString(getDomNodeValue(dereference(getDomChildAt(Element, null, "obstructPath", index))));
	}

	public org.w3c.dom.Node getStartingobstructPathCursor() throws Exception {
		return getDomFirstChild(Element, null, "obstructPath" );
	}

	public org.w3c.dom.Node getAdvancedobstructPathCursor( org.w3c.dom.Node curNode ) throws Exception {
		return getDomNextChild( Element, null, "obstructPath", curNode );
	}

	public SchemaString getobstructPathValueAtCursor( org.w3c.dom.Node curNode ) throws Exception {
		if( curNode == null )
			throw new com.altova.xml.XmlException("Out of range");
		else
			return new SchemaString(getDomNodeValue( dereference(curNode) ) );
	}

	public SchemaString getobstructPath() throws Exception 
 {
		return getobstructPathAt(0);
	}

	public void removeobstructPathAt(int index) {
		removeDomChildAt(Element, null, "obstructPath", index);
	}

	public void removeobstructPath() {
		while (hasobstructPath())
			removeobstructPathAt(0);
	}

	public void addobstructPath(SchemaString value) {
		if( value.isNull() == false )
		{
			appendDomChild(Element, null, "obstructPath", value.toString());
		}
	}

	public void addobstructPath(String value) throws Exception {
		addobstructPath(new SchemaString(value));
	}

	public void insertobstructPathAt(SchemaString value, int index) {
		insertDomChildAt(Element, null, "obstructPath", index, value.toString());
	}

	public void insertobstructPathAt(String value, int index) throws Exception {
		insertobstructPathAt(new SchemaString(value), index);
	}

	public void replaceobstructPathAt(SchemaString value, int index) {
		replaceDomChildAt(Element, null, "obstructPath", index, value.toString());
	}

	public void replaceobstructPathAt(String value, int index) throws Exception {
		replaceobstructPathAt(new SchemaString(value), index);
	}

	public static int getcellSizeMinCount() {
		return 1;
	}

	public static int getcellSizeMaxCount() {
		return 1;
	}

	public int getcellSizeCount() {
		return getDomChildCount(Element, null, "cellSize");
	}

	public boolean hascellSize() {
		return hasDomChild(Element, null, "cellSize");
	}

	public SchemaDouble newcellSize() {
		return new SchemaDouble();
	}

	public SchemaDouble getcellSizeAt(int index) throws Exception {
		return new SchemaDouble(getDomNodeValue(dereference(getDomChildAt(Element, null, "cellSize", index))));
	}

	public org.w3c.dom.Node getStartingcellSizeCursor() throws Exception {
		return getDomFirstChild(Element, null, "cellSize" );
	}

	public org.w3c.dom.Node getAdvancedcellSizeCursor( org.w3c.dom.Node curNode ) throws Exception {
		return getDomNextChild( Element, null, "cellSize", curNode );
	}

	public SchemaDouble getcellSizeValueAtCursor( org.w3c.dom.Node curNode ) throws Exception {
		if( curNode == null )
			throw new com.altova.xml.XmlException("Out of range");
		else
			return new SchemaDouble(getDomNodeValue( dereference(curNode) ) );
	}

	public SchemaDouble getcellSize() throws Exception 
 {
		return getcellSizeAt(0);
	}

	public void removecellSizeAt(int index) {
		removeDomChildAt(Element, null, "cellSize", index);
	}

	public void removecellSize() {
		while (hascellSize())
			removecellSizeAt(0);
	}

	public void addcellSize(SchemaDouble value) {
		if( value.isNull() == false )
		{
			appendDomChild(Element, null, "cellSize", value.toString());
		}
	}

	public void addcellSize(String value) throws Exception {
		addcellSize(new SchemaDouble(value));
	}

	public void insertcellSizeAt(SchemaDouble value, int index) {
		insertDomChildAt(Element, null, "cellSize", index, value.toString());
	}

	public void insertcellSizeAt(String value, int index) throws Exception {
		insertcellSizeAt(new SchemaDouble(value), index);
	}

	public void replacecellSizeAt(SchemaDouble value, int index) {
		replaceDomChildAt(Element, null, "cellSize", index, value.toString());
	}

	public void replacecellSizeAt(String value, int index) throws Exception {
		replacecellSizeAt(new SchemaDouble(value), index);
	}

	public static int getbgMapPathMinCount() {
		return 0;
	}

	public static int getbgMapPathMaxCount() {
		return Integer.MAX_VALUE;
	}

	public int getbgMapPathCount() {
		return getDomChildCount(Element, null, "bgMapPath");
	}

	public boolean hasbgMapPath() {
		return hasDomChild(Element, null, "bgMapPath");
	}

	public SchemaString newbgMapPath() {
		return new SchemaString();
	}

	public SchemaString getbgMapPathAt(int index) throws Exception {
		return new SchemaString(getDomNodeValue(dereference(getDomChildAt(Element, null, "bgMapPath", index))));
	}

	public org.w3c.dom.Node getStartingbgMapPathCursor() throws Exception {
		return getDomFirstChild(Element, null, "bgMapPath" );
	}

	public org.w3c.dom.Node getAdvancedbgMapPathCursor( org.w3c.dom.Node curNode ) throws Exception {
		return getDomNextChild( Element, null, "bgMapPath", curNode );
	}

	public SchemaString getbgMapPathValueAtCursor( org.w3c.dom.Node curNode ) throws Exception {
		if( curNode == null )
			throw new com.altova.xml.XmlException("Out of range");
		else
			return new SchemaString(getDomNodeValue( dereference(curNode) ) );
	}

	public SchemaString getbgMapPath() throws Exception 
 {
		return getbgMapPathAt(0);
	}

	public void removebgMapPathAt(int index) {
		removeDomChildAt(Element, null, "bgMapPath", index);
	}

	public void removebgMapPath() {
		while (hasbgMapPath())
			removebgMapPathAt(0);
	}

	public void addbgMapPath(SchemaString value) {
		if( value.isNull() == false )
		{
			appendDomChild(Element, null, "bgMapPath", value.toString());
		}
	}

	public void addbgMapPath(String value) throws Exception {
		addbgMapPath(new SchemaString(value));
	}

	public void insertbgMapPathAt(SchemaString value, int index) {
		insertDomChildAt(Element, null, "bgMapPath", index, value.toString());
	}

	public void insertbgMapPathAt(String value, int index) throws Exception {
		insertbgMapPathAt(new SchemaString(value), index);
	}

	public void replacebgMapPathAt(SchemaString value, int index) {
		replaceDomChildAt(Element, null, "bgMapPath", index, value.toString());
	}

	public void replacebgMapPathAt(String value, int index) throws Exception {
		replacebgMapPathAt(new SchemaString(value), index);
	}

	public static int getFFTableMinCount() {
		return 0;
	}

	public static int getFFTableMaxCount() {
		return Integer.MAX_VALUE;
	}

	public int getFFTableCount() {
		return getDomChildCount(Element, null, "FFTable");
	}

	public boolean hasFFTable() {
		return hasDomChild(Element, null, "FFTable");
	}

	public SchemaString newFFTable() {
		return new SchemaString();
	}

	public SchemaString getFFTableAt(int index) throws Exception {
		return new SchemaString(getDomNodeValue(dereference(getDomChildAt(Element, null, "FFTable", index))));
	}

	public org.w3c.dom.Node getStartingFFTableCursor() throws Exception {
		return getDomFirstChild(Element, null, "FFTable" );
	}

	public org.w3c.dom.Node getAdvancedFFTableCursor( org.w3c.dom.Node curNode ) throws Exception {
		return getDomNextChild( Element, null, "FFTable", curNode );
	}

	public SchemaString getFFTableValueAtCursor( org.w3c.dom.Node curNode ) throws Exception {
		if( curNode == null )
			throw new com.altova.xml.XmlException("Out of range");
		else
			return new SchemaString(getDomNodeValue( dereference(curNode) ) );
	}

	public SchemaString getFFTable() throws Exception 
 {
		return getFFTableAt(0);
	}

	public void removeFFTableAt(int index) {
		removeDomChildAt(Element, null, "FFTable", index);
	}

	public void removeFFTable() {
		while (hasFFTable())
			removeFFTableAt(0);
	}

	public void addFFTable(SchemaString value) {
		if( value.isNull() == false )
		{
			appendDomChild(Element, null, "FFTable", value.toString());
		}
	}

	public void addFFTable(String value) throws Exception {
		addFFTable(new SchemaString(value));
	}

	public void insertFFTableAt(SchemaString value, int index) {
		insertDomChildAt(Element, null, "FFTable", index, value.toString());
	}

	public void insertFFTableAt(String value, int index) throws Exception {
		insertFFTableAt(new SchemaString(value), index);
	}

	public void replaceFFTableAt(SchemaString value, int index) {
		replaceDomChildAt(Element, null, "FFTable", index, value.toString());
	}

	public void replaceFFTableAt(String value, int index) throws Exception {
		replaceFFTableAt(new SchemaString(value), index);
	}

	private org.w3c.dom.Node dereference(org.w3c.dom.Node node) {
		return node;
	}
}
